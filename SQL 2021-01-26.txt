
MADANG 2023-01-26
================

CREATE USER orclstudy
IDENTIFIED BY  orclstudy;
--SYSTEM

GRANT CONNECT, RESOURCE TO orclstudy;

EXIT;

SELECT*
FROM SCOTT.EMP;
--안된다
/*
권한주기
SYSTEM 들어가서
GRANT SELECT ON EMP TO ORCLSTUDY;
DML: SELECT, INSERT, UPDATE, DELETE
DDL: CREATE, ALTER, RENAME, TRUNCCATE, DROP
DCL: GRANT, REVOKE
TCL: COMMIT, ROLLBACK

*/

--가격이 10000원 이상 20000이하 책 검색
SELECT *
FROM BOOK
WHERE PRICE BETWEEN 10000 AND 20000;

--출판사가 대한미디어, 이상미디어인 도서이름, 출판사
SELECT BOOKNAME, PUBLISHER
FROM BOOK
WHERE PUBLISHER IN('대한미디어', '이상미디어');

--책 가격의 최댓값은?
SELECT MAX(PRICE)
FROM BOOK;

--가장 비싼 책의 이름은?
SELECT BOOKNAME
FROM BOOK
WHERE PRICE = (SELECT MAX(PRICE)   
                FROM BOOK);

--출판사별 가격의 최댓값은?
SELECT MAX(PRICE), PUBLISHER
FROM BOOK
GROUP BY PUBLISHER;

--출판사별 책가격이 최댓값인 책 이름은?
SELECT BOOKNAME, PRICE, PUBLISHER
FROM BOOK
WHERE PRICE IN (SELECT MAX(PRICE)
                    FROM BOOK
                    GROUP BY PUBLISHER);

SELECT * FROM CUSTOMER;
SELECT * FROM ORDERS;

SELECT B.PRICE, O.SALEPRICE
FROM BOOK B, ORDERS O
WHERE B.BOOKID = O.BOOKID;

--고객의 이름과 고객이 주문한 도서의 판매가격(SALEPRICE)을 검색
SELECT C.NAME, O.SALEPRICE
FROM CUSTOMER C, ORDERS O
WHERE C.CUSTID = O.CUSTID;

--고객의 이름과 고객이 주문한 도서의 이름
SELECT C.NAME, B.BOOKNAME
FROM BOOK B, CUSTOMER C, ORDERS O
WHERE B.BOOKID = O.BOOKID
    AND C.CUSTID = O.CUSTID;

--고객의 이름과 고객이 주문한 도서의 이름 중 가격이 20000원이상
SELECT C.NAME, B.BOOKNAME, B.PRICE
FROM BOOK B, CUSTOMER C, ORDERS O
WHERE B.BOOKID = O.BOOKID
    AND C.CUSTID = O.CUSTID
    AND B.PRICE >= 20000;


SELECT C.NAME, B.BOOKNAME 
FROM CUSTOMER C, ORDERS O, BOOK B 
WHERE O.CUSTID = C.CUSTID 
    AND O.BOOKID = B.BOOKID
    AND O.SALEPRICE >= 20000; 

--이거를 SQL99방식으로 바꿔보래
SELECT C.NAME, B.BOOKNAME 
FROM CUSTOMER C JOIN ORDERS O ON(O.CUSTID = C.CUSTID)
    JOIN BOOK B ON(O.BOOKID = B.BOOKID)
WHERE O.SALEPRICE >= 20000; 
--괄호 붙여도 안붙여도 된데

-- 다음을 SQL99방식으로 해라
SELECT C.NAME, B.BOOKNAME
FROM CUSTOMER C JOIN ORDERS O ON C.CUSTID = O.CUSTID
    JOIN BOOK B ON O.BOOKID = B.BOOKID;

SELECT C.NAME, B.BOOKNAME 
FROM CUSTOMER C 
LEFT OUTER JOIN ORDERS O USING(CUSTID) 
LEFT OUTER JOIN BOOK B USING(BOOKID) 
WHERE O.SALEPRICE >= 20000; 

SELECT C.NAME, B.BOOKNAME 
FROM CUSTOMER C 
LEFT OUTER JOIN ORDERS O USING(CUSTID) 
LEFT OUTER JOIN BOOK B USING(BOOKID); 

--고객별로 주문한 도서의 총 판매액을 구하고, 고객별로 정렬
SELECT C.NAME, SUM(SALEPRICE)
FROM CUSTOMER C JOIN ORDERS USING(CUSTID)
GROUP BY C.NAME; 

SELECT NAME, TOTALPRICE 
FROM CUSTOMER C JOIN (SELECT CUSTID, SUM(SALEPRICE) 
    AS TOTALPRICE 
FROM ORDERS 
GROUP BY CUSTID) USING(CUSTID) 
ORDER BY NAME; 

SELECT C.NAME, SUM(O.SALEPRICE)
FROM  CUSTOMER C JOIN ORDERS O USING(CUSTID)
GROUP BY C.NAME; 

--여기까지 오전수업

==================================

SCOTT 2023-01-26

==============================




/*
NATURAL JOIN
NATURAL JOIN은 앞에서 소개한 등가 조인을 대신해 사용할 수 있는 조인 방식
조인 대상이 되는 두 테이블에 이름과 자료형이 같은 열을 찾은 후 그 열을
기준으로 등가조인을 해주는 방식
*/
--NATURAL JOIN을 


SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM,
    DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO;

--기준열인 DEPTNO을 SELECT절에 명시할 때 테이블 이름을 붙이면 안 되는 특성

--JOIN ~ USING

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM,
    DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D USING(DEPTNO)
WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO;

/*
다음 SQL문은 JOIN~USING 키워드를 사용한 등가 조인이다
조건에 알맞도록 SQL문을 채워라
조건1 EMP테이블과 DEPT 테이블의 조인 조건은 부서번호(DEPTNO)가 같을 때다
조건2 급여는 3000 이상이며 직속상관이 반드시 있어야 한다

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM
FROM
WHERE
ORDER BY
*/

SELECT  E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM
FROM EMP E JOIN DEPT D USING(DEPTNO)
WHERE E.SAL >= 3000
    AND E.MGR IS NOT NULL;

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM 
FROM EMP E JOIN DEPT D USING(DEPTNO) 
WHERE E.SAL >= 3000 
    AND E.MGR IS NOT NULL; 



